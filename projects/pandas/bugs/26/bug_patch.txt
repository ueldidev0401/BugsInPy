diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index af7beb0b3..8b6ed002b 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -740,7 +740,7 @@ class DatetimeLikeArrayMixin(
         return fill_value
 
     def _validate_shift_value(self, fill_value):
-        # TODO(2.0): once this deprecation is enforced, used _validate_fill_value
+        # TODO(2.0): once this deprecation is enforced, use _validate_fill_value
         if is_valid_nat_for_dtype(fill_value, self.dtype):
             fill_value = NaT
         elif isinstance(fill_value, self._recognized_scalars):
@@ -782,6 +782,9 @@ class DatetimeLikeArrayMixin(
         elif isinstance(value, self._recognized_scalars):
             value = self._scalar_type(value)
 
+        elif isinstance(value, type(self)):
+            pass
+
         elif is_list_like(value) and not isinstance(value, type(self)):
             value = array(value)
 
@@ -791,7 +794,7 @@ class DatetimeLikeArrayMixin(
                     f"not {type(value).__name__}"
                 )
 
-        if not (isinstance(value, (self._scalar_type, type(self))) or (value is NaT)):
+        else:
             raise TypeError(f"Unexpected type for 'value': {type(value)}")
 
         if isinstance(value, type(self)):
@@ -803,18 +806,28 @@ class DatetimeLikeArrayMixin(
         return value
 
     def _validate_setitem_value(self, value):
-        if lib.is_scalar(value) and not isna(value):
-            value = com.maybe_box_datetimelike(value)
 
         if is_list_like(value):
-            value = type(self)._from_sequence(value, dtype=self.dtype)
-            self._check_compatible_with(value, setitem=True)
-            value = value.asi8
-        elif isinstance(value, self._scalar_type):
-            self._check_compatible_with(value, setitem=True)
-            value = self._unbox_scalar(value)
+            value = array(value)
+            if is_dtype_equal(value.dtype, "string"):
+                # We got a StringArray
+                try:
+                    # TODO: Could use from_sequence_of_strings if implemented
+                    # Note: passing dtype is necessary for PeriodArray tests
+                    value = type(self)._from_sequence(value, dtype=self.dtype)
+                except ValueError:
+                    pass
+
+            if not type(self)._is_recognized_dtype(value):
+                raise TypeError(
+                    "setitem requires compatible dtype or scalar, "
+                    f"not {type(value).__name__}"
+                )
+
+        elif isinstance(value, self._recognized_scalars):
+            value = self._scalar_type(value)
         elif is_valid_nat_for_dtype(value, self.dtype):
-            value = iNaT
+            value = NaT
         else:
             msg = (
                 f"'value' should be a '{self._scalar_type.__name__}', 'NaT', "
@@ -822,6 +835,12 @@ class DatetimeLikeArrayMixin(
             )
             raise TypeError(msg)
 
+        self._check_compatible_with(value, setitem=True)
+        if isinstance(value, type(self)):
+            value = value.asi8
+        else:
+            value = self._unbox_scalar(value)
+
         return value
 
     def _validate_insert_value(self, value):
