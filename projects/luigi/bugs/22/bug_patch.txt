diff --git a/luigi/task.py b/luigi/task.py
index fe643265..1b17c6db 100644
--- a/luigi/task.py
+++ b/luigi/task.py
@@ -239,6 +239,8 @@ class Task(object):
         # TODO(erikbern): we should think about a language-agnostic mechanism
         return self.__class__.__module__
 
+    _visible_in_registry = True  # TODO: Consider using in luigi.util as well
+
     __not_user_specified = '__not_user_specified'
 
     task_namespace = __not_user_specified
@@ -724,7 +726,7 @@ def externalize(taskclass_or_taskobject):
         @_task_wraps(clazz)
         class _CopyOfClass(clazz):
             # How to copy a class: http://stackoverflow.com/a/9541120/621449
-            pass
+            _visible_in_registry = False
         _CopyOfClass.run = None
         return _CopyOfClass
     else:
diff --git a/luigi/task_register.py b/luigi/task_register.py
index 4d094994..6e2afa57 100644
--- a/luigi/task_register.py
+++ b/luigi/task_register.py
@@ -19,7 +19,6 @@ Define the centralized register of all :class:`~luigi.task.Task` classes.
 """
 
 import abc
-from collections import OrderedDict
 
 from luigi import six
 import logging
@@ -129,23 +128,24 @@ class Register(abc.ABCMeta):
     def _get_reg(cls):
         """Return all of the registered classes.
 
-        :return:  an ``collections.OrderedDict`` of task_family -> class
+        :return:  an ``dict`` of task_family -> class
         """
         # We have to do this on-demand in case task names have changed later
-        # We return this in a topologically sorted list of inheritance: this is useful in some cases (#822)
-        reg = OrderedDict()
-        for cls in cls._reg:
-            name = cls.task_family
-
-            if name in reg and reg[name] != cls and \
-                    reg[name] != cls.AMBIGUOUS_CLASS and \
-                    not issubclass(cls, reg[name]):
+        reg = dict()
+        for task_cls in cls._reg:
+            if not task_cls._visible_in_registry:
+                continue
+
+            name = task_cls.get_task_family()
+            if name in reg and \
+                    (reg[name] == Register.AMBIGUOUS_CLASS or  # Check so issubclass doesn't crash
+                     not issubclass(task_cls, reg[name])):
                 # Registering two different classes - this means we can't instantiate them by name
                 # The only exception is if one class is a subclass of the other. In that case, we
                 # instantiate the most-derived class (this fixes some issues with decorator wrappers).
-                reg[name] = cls.AMBIGUOUS_CLASS
+                reg[name] = Register.AMBIGUOUS_CLASS
             else:
-                reg[name] = cls
+                reg[name] = task_cls
 
         return reg
 
diff --git a/test/util_test.py b/test/util_test.py
index b3adffda..330566c6 100644
--- a/test/util_test.py
+++ b/test/util_test.py
@@ -14,7 +14,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
-from helpers import LuigiTestCase
+from helpers import LuigiTestCase, RunOnceTask
 
 import luigi
 import luigi.task
@@ -23,25 +23,25 @@ from luigi.util import requires
 
 class BasicsTest(LuigiTestCase):
 
-    def test_requries(self):
-        class BaseTask(luigi.Task):
+    def test_task_ids_using_requries(self):
+        class ParentTask(luigi.Task):
             my_param = luigi.Parameter()
         luigi.namespace('blah')
 
-        @requires(BaseTask)
+        @requires(ParentTask)
         class ChildTask(luigi.Task):
             pass
         luigi.namespace('')
         child_task = ChildTask(my_param='hello')
         self.assertEqual(str(child_task), 'blah.ChildTask(my_param=hello)')
-        self.assertIn(BaseTask(my_param='hello'), luigi.task.flatten(child_task.requires()))
+        self.assertIn(ParentTask(my_param='hello'), luigi.task.flatten(child_task.requires()))
 
-    def test_requries_weird_way(self):
+    def test_task_ids_using_requries_2(self):
         # Here we use this decorator in a unnormal way.
         # But it should still work.
-        class BaseTask(luigi.Task):
+        class ParentTask(luigi.Task):
             my_param = luigi.Parameter()
-        decorator = requires(BaseTask)
+        decorator = requires(ParentTask)
         luigi.namespace('blah')
 
         class ChildTask(luigi.Task):
@@ -50,4 +50,31 @@ class BasicsTest(LuigiTestCase):
         ChildTask = decorator(ChildTask)
         child_task = ChildTask(my_param='hello')
         self.assertEqual(str(child_task), 'blah.ChildTask(my_param=hello)')
-        self.assertIn(BaseTask(my_param='hello'), luigi.task.flatten(child_task.requires()))
+        self.assertIn(ParentTask(my_param='hello'), luigi.task.flatten(child_task.requires()))
+
+    def _setup_parent_and_child(self):
+        class ParentTask(luigi.Task):
+            my_parameter = luigi.Parameter()
+            class_variable = 'notset'
+
+            def run(self):
+                self.__class__.class_variable = self.my_parameter
+
+            def complete(self):
+                return self.class_variable == 'actuallyset'
+
+        @requires(ParentTask)
+        class ChildTask(RunOnceTask):
+            pass
+
+        return ParentTask
+
+    def test_requires_has_effect_run_child(self):
+        ParentTask = self._setup_parent_and_child()
+        self.assertTrue(self.run_locally_split('ChildTask --my-parameter actuallyset'))
+        self.assertEqual(ParentTask.class_variable, 'actuallyset')
+
+    def test_requires_has_effect_run_parent(self):
+        ParentTask = self._setup_parent_and_child()
+        self.assertTrue(self.run_locally_split('ParentTask --my-parameter actuallyset'))
+        self.assertEqual(ParentTask.class_variable, 'actuallyset')
