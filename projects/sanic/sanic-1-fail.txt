OUTPUT AT FIXED COMMIT ID
pytest tests/test_reloader.py::test_reloader_live
============================= test session starts =============================
platform win32 -- Python 3.8.3, pytest-5.2.1, py-1.8.1, pluggy-0.13.1
benchmark: 3.2.3 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: C:\Users\Camellia\Desktop\BugsInPy\projects\sanic\sanic, inifile: tox.ini
plugins: benchmark-3.2.3, cov-2.9.0, sanic-1.6.1, sugar-0.9.3
collected 3 items

tests\test_reloader.py FFF                                               [100%]

================================== FAILURES ===================================
_____________________ test_reloader_live[runargs0-script] _____________________

runargs = {'auto_reload': True, 'port': 42102}, mode = 'script'

    @pytest.mark.parametrize("runargs, mode", [
        (dict(port=42102, auto_reload=True), "script"),
        (dict(port=42103, debug=True), "module"),
        (dict(), "sanic"),
    ])
    async def test_reloader_live(runargs, mode):
        with TemporaryDirectory() as tmpdir:
            filename = os.path.join(tmpdir, "reloader.py")
            text = write_app(filename, **runargs)
            proc = Popen(argv[mode], cwd=tmpdir, stdout=PIPE, creationflags=flags)
            try:
                timeout = Timer(5, terminate, [proc])
                timeout.start()
                # Python apparently keeps using the old source sometimes if
                # we don't sleep before rewrite (pycache timestamp problem?)
                sleep(1)
                line = scanner(proc)
>               assert text in next(line)
E               StopIteration

tests\test_reloader.py:81: StopIteration

The above exception was the direct cause of the following exception:

pyfuncitem = <Function test_reloader_live[runargs0-script]>

    def pytest_pyfunc_call(pyfuncitem):
        """
        Run test coroutines in an event loop.
        """
        if _is_coroutine(pyfuncitem.function):
            loop = pyfuncitem.funcargs[LOOP_KEY]
            funcargs = pyfuncitem.funcargs
            testargs = {}
            for arg in pyfuncitem._fixtureinfo.argnames:
                testargs[arg] = funcargs[arg]
>           loop.run_until_complete(
                loop.create_task(
                    pyfuncitem.obj(**testargs)
                )
            )

env\lib\site-packages\pytest_sanic\plugin.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ProactorEventLoop running=False closed=False debug=False>
future = <Task finished name='Task-1' coro=<test_reloader_live() done, defined at C:\Users\Camellia\Desktop\BugsInPy\projects\sanic\sanic\tests\test_reloader.py:64> exception=RuntimeError('coroutine raised StopIteration')>

    def run_until_complete(self, future):
        """Run until the Future is done.
    
        If the argument is a coroutine, it is wrapped in a Task.
    
        WARNING: It would be disastrous to call run_until_complete()
        with the same coroutine twice -- it would wrap it in two
        different Tasks and that can't be good.
    
        Return the Future's result, or raise its exception.
        """
        self._check_closed()
        self._check_running()
    
        new_task = not futures.isfuture(future)
        future = tasks.ensure_future(future, loop=self)
        if new_task:
            # An exception is raised if the future didn't complete, so there
            # is no need to log the "destroy pending task" message
            future._log_destroy_pending = False
    
        future.add_done_callback(_run_until_complete_cb)
        try:
            self.run_forever()
        except:
            if new_task and future.done() and not future.cancelled():
                # The coroutine raised a BaseException. Consume the exception
                # to not log a warning, the caller doesn't have access to the
                # local task.
                future.exception()
            raise
        finally:
            future.remove_done_callback(_run_until_complete_cb)
        if not future.done():
            raise RuntimeError('Event loop stopped before Future completed.')
    
>       return future.result()
E       RuntimeError: coroutine raised StopIteration

..\..\..\..\..\AppData\Local\Programs\Python\Python38\lib\asyncio\base_events.py:616: RuntimeError
---------------------------- Captured stdout call -----------------------------
> [2020-06-10 13:08:52 +0800] [14304] [INFO] Goin' Fast @ http://127.0.0.1:42102
---------------------------- Captured stderr call -----------------------------
[2020-06-10 13:08:52 +0800] [14304] [ERROR] Experienced exception while trying to serve
Traceback (most recent call last):
  File "c:\users\camellia\desktop\bugsinpy\projects\sanic\sanic\env\src\sanic\sanic\app.py", line 1162, in run
    raise NotImplementedError
NotImplementedError
Traceback (most recent call last):
  File "reloader.py", line 11, in <module>
    app.run(**{'port': 42102, 'auto_reload': True})
  File "c:\users\camellia\desktop\bugsinpy\projects\sanic\sanic\env\src\sanic\sanic\app.py", line 1162, in run
    raise NotImplementedError
NotImplementedError
_____________________ test_reloader_live[runargs1-module] _____________________

runargs = {'debug': True, 'port': 42103}, mode = 'module'

    @pytest.mark.parametrize("runargs, mode", [
        (dict(port=42102, auto_reload=True), "script"),
        (dict(port=42103, debug=True), "module"),
        (dict(), "sanic"),
    ])
    async def test_reloader_live(runargs, mode):
        with TemporaryDirectory() as tmpdir:
            filename = os.path.join(tmpdir, "reloader.py")
            text = write_app(filename, **runargs)
            proc = Popen(argv[mode], cwd=tmpdir, stdout=PIPE, creationflags=flags)
            try:
                timeout = Timer(5, terminate, [proc])
                timeout.start()
                # Python apparently keeps using the old source sometimes if
                # we don't sleep before rewrite (pycache timestamp problem?)
                sleep(1)
                line = scanner(proc)
                assert text in next(line)
                # Edit source code and try again
                text = write_app(filename, **runargs)
>               assert text in next(line)
E               StopIteration

tests\test_reloader.py:84: StopIteration

The above exception was the direct cause of the following exception:

pyfuncitem = <Function test_reloader_live[runargs1-module]>

    def pytest_pyfunc_call(pyfuncitem):
        """
        Run test coroutines in an event loop.
        """
        if _is_coroutine(pyfuncitem.function):
            loop = pyfuncitem.funcargs[LOOP_KEY]
            funcargs = pyfuncitem.funcargs
            testargs = {}
            for arg in pyfuncitem._fixtureinfo.argnames:
                testargs[arg] = funcargs[arg]
>           loop.run_until_complete(
                loop.create_task(
                    pyfuncitem.obj(**testargs)
                )
            )

env\lib\site-packages\pytest_sanic\plugin.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ProactorEventLoop running=False closed=False debug=False>
future = <Task finished name='Task-2' coro=<test_reloader_live() done, defined at C:\Users\Camellia\Desktop\BugsInPy\projects\sanic\sanic\tests\test_reloader.py:64> exception=RuntimeError('coroutine raised StopIteration')>

    def run_until_complete(self, future):
        """Run until the Future is done.
    
        If the argument is a coroutine, it is wrapped in a Task.
    
        WARNING: It would be disastrous to call run_until_complete()
        with the same coroutine twice -- it would wrap it in two
        different Tasks and that can't be good.
    
        Return the Future's result, or raise its exception.
        """
        self._check_closed()
        self._check_running()
    
        new_task = not futures.isfuture(future)
        future = tasks.ensure_future(future, loop=self)
        if new_task:
            # An exception is raised if the future didn't complete, so there
            # is no need to log the "destroy pending task" message
            future._log_destroy_pending = False
    
        future.add_done_callback(_run_until_complete_cb)
        try:
            self.run_forever()
        except:
            if new_task and future.done() and not future.cancelled():
                # The coroutine raised a BaseException. Consume the exception
                # to not log a warning, the caller doesn't have access to the
                # local task.
                future.exception()
            raise
        finally:
            future.remove_done_callback(_run_until_complete_cb)
        if not future.done():
            raise RuntimeError('Event loop stopped before Future completed.')
    
>       return future.result()
E       RuntimeError: coroutine raised StopIteration

..\..\..\..\..\AppData\Local\Programs\Python\Python38\lib\asyncio\base_events.py:616: RuntimeError
---------------------------- Captured stdout call -----------------------------
> [2020-06-10 13:08:54 +0800] [23228] [DEBUG]
> 
> Sanic
> Build Fast. Run Fast.
> 
> 
> [2020-06-10 13:08:54 +0800] [23228] [INFO] Goin' Fast @ http://127.0.0.1:42103
> complete 23228 CbBp3GJ8ljX7Tg7Wxr0bKZlU-UqN2XyLjrjOmXX9k8E
> [2020-06-10 13:08:54 +0800] [23228] [INFO] Starting worker [23228]
_____________________ test_reloader_live[runargs2-sanic] ______________________

runargs = {}, mode = 'sanic'

    @pytest.mark.parametrize("runargs, mode", [
        (dict(port=42102, auto_reload=True), "script"),
        (dict(port=42103, debug=True), "module"),
        (dict(), "sanic"),
    ])
    async def test_reloader_live(runargs, mode):
        with TemporaryDirectory() as tmpdir:
            filename = os.path.join(tmpdir, "reloader.py")
            text = write_app(filename, **runargs)
            proc = Popen(argv[mode], cwd=tmpdir, stdout=PIPE, creationflags=flags)
            try:
                timeout = Timer(5, terminate, [proc])
                timeout.start()
                # Python apparently keeps using the old source sometimes if
                # we don't sleep before rewrite (pycache timestamp problem?)
                sleep(1)
                line = scanner(proc)
                assert text in next(line)
                # Edit source code and try again
                text = write_app(filename, **runargs)
>               assert text in next(line)
E               StopIteration

tests\test_reloader.py:84: StopIteration

The above exception was the direct cause of the following exception:

pyfuncitem = <Function test_reloader_live[runargs2-sanic]>

    def pytest_pyfunc_call(pyfuncitem):
        """
        Run test coroutines in an event loop.
        """
        if _is_coroutine(pyfuncitem.function):
            loop = pyfuncitem.funcargs[LOOP_KEY]
            funcargs = pyfuncitem.funcargs
            testargs = {}
            for arg in pyfuncitem._fixtureinfo.argnames:
                testargs[arg] = funcargs[arg]
>           loop.run_until_complete(
                loop.create_task(
                    pyfuncitem.obj(**testargs)
                )
            )

env\lib\site-packages\pytest_sanic\plugin.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ProactorEventLoop running=False closed=False debug=False>
future = <Task finished name='Task-3' coro=<test_reloader_live() done, defined at C:\Users\Camellia\Desktop\BugsInPy\projects\sanic\sanic\tests\test_reloader.py:64> exception=RuntimeError('coroutine raised StopIteration')>

    def run_until_complete(self, future):
        """Run until the Future is done.
    
        If the argument is a coroutine, it is wrapped in a Task.
    
        WARNING: It would be disastrous to call run_until_complete()
        with the same coroutine twice -- it would wrap it in two
        different Tasks and that can't be good.
    
        Return the Future's result, or raise its exception.
        """
        self._check_closed()
        self._check_running()
    
        new_task = not futures.isfuture(future)
        future = tasks.ensure_future(future, loop=self)
        if new_task:
            # An exception is raised if the future didn't complete, so there
            # is no need to log the "destroy pending task" message
            future._log_destroy_pending = False
    
        future.add_done_callback(_run_until_complete_cb)
        try:
            self.run_forever()
        except:
            if new_task and future.done() and not future.cancelled():
                # The coroutine raised a BaseException. Consume the exception
                # to not log a warning, the caller doesn't have access to the
                # local task.
                future.exception()
            raise
        finally:
            future.remove_done_callback(_run_until_complete_cb)
        if not future.done():
            raise RuntimeError('Event loop stopped before Future completed.')
    
>       return future.result()
E       RuntimeError: coroutine raised StopIteration

..\..\..\..\..\AppData\Local\Programs\Python\Python38\lib\asyncio\base_events.py:616: RuntimeError
---------------------------- Captured stdout call -----------------------------
> [2020-06-10 13:08:59 +0800] [18108] [DEBUG]
> 
> Sanic
> Build Fast. Run Fast.
> 
> 
> [2020-06-10 13:08:59 +0800] [18108] [INFO] Goin' Fast @ http://127.0.0.1:42104
> complete 18108 -Whd8A6kqSbYxuzMq5_kS4pUv0jVjLJG4s126yB0kSY
> [2020-06-10 13:08:59 +0800] [18108] [INFO] Starting worker [18108]
============================= 3 failed in 12.39s ==============================
