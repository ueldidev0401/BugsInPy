diff --git a/lib/ansible/modules/storage/netapp/netapp_e_volume.py b/lib/ansible/modules/storage/netapp/netapp_e_volume.py
index 0483b998b8..1bc5cce94c 100644
--- a/lib/ansible/modules/storage/netapp/netapp_e_volume.py
+++ b/lib/ansible/modules/storage/netapp/netapp_e_volume.py
@@ -130,13 +130,13 @@ options:
             - This option has no effect on thinly provisioned volumes since the architecture for thin volumes cannot
               benefit from read ahead caching.
         type: bool
-        default: false
+        default: true
         version_added: 2.8
     write_cache_enable:
         description:
             - Indicates whether write-back caching should be enabled for the volume.
         type: bool
-        default: false
+        default: true
         version_added: 2.8
     workload_name:
         description:
@@ -164,6 +164,13 @@ options:
         type: bool
         default: false
         version_added: 2.8
+    initialization_timeout:
+        description:
+            - Duration in seconds before the wait_for_initialization operation will terminate.
+            - M(wait_for_initialization==True) to have any effect on module's operations.
+        type: int
+        required: false
+        version_added: 2.9
 """
 EXAMPLES = """
 - name: Create simple volume with workload tags (volume meta data)
@@ -244,9 +251,7 @@ msg:
     returned: always
     sample: "Standard volume [workload_vol_1] has been created."
 """
-
-import time
-
+from time import sleep
 from ansible.module_utils.netapp import NetAppESeriesModule
 from ansible.module_utils._text import to_native
 
@@ -271,11 +276,12 @@ class NetAppESeriesVolume(NetAppESeriesModule):
             thin_volume_expansion_policy=dict(type="str", choices=["automatic", "manual"]),
             thin_volume_growth_alert_threshold=dict(type="int", default=95),
             read_cache_enable=dict(type="bool", default=True),
-            read_ahead_enable=dict(type="bool", default=False),
-            write_cache_enable=dict(type="bool", default=False),
+            read_ahead_enable=dict(type="bool", default=True),
+            write_cache_enable=dict(type="bool", default=True),
             workload_name=dict(type="str", required=False),
             metadata=dict(type="dict", require=False),
-            wait_for_initialization=dict(type="bool", default=False))
+            wait_for_initialization=dict(type="bool", default=False),
+            initialization_timeout=dict(type="int", required=False))
 
         required_if = [
             ["state", "present", ["storage_pool_name", "size"]],
@@ -317,6 +323,7 @@ class NetAppESeriesVolume(NetAppESeriesModule):
         self.workload_name = args["workload_name"]
         self.metadata = args["metadata"]
         self.wait_for_initialization = args["wait_for_initialization"]
+        self.initialization_timeout = args["initialization_timeout"]
 
         # convert metadata to a list of dictionaries containing the keys "key" and "value" corresponding to
         #   each of the workload attributes dictionary entries
@@ -381,37 +388,44 @@ class NetAppESeriesVolume(NetAppESeriesModule):
             self.module.fail_json(msg="Timed out waiting for the volume %s to become available. Array [%s]."
                                       % (self.name, self.ssid))
         if not self.get_volume():
-            time.sleep(5)
+            sleep(5)
             self.wait_for_volume_availability(retries=retries - 1)
 
     def wait_for_volume_action(self, timeout=None):
         """Waits until volume action is complete is complete.
         :param: int timeout: Wait duration measured in seconds. Waits indefinitely when None.
         """
-        action = None
+        action = "unknown"
         percent_complete = None
-
-        while action != 'none':
-            time.sleep(5)
+        while action != "complete":
+            sleep(5)
 
             try:
-                rc, expansion = self.request("storage-systems/%s/volumes/%s/expand"
-                                             % (self.ssid, self.volume_detail["id"]))
-                action = expansion["action"]
-                percent_complete = expansion["percentComplete"]
+                rc, operations = self.request("storage-systems/%s/symbol/getLongLivedOpsProgress" % self.ssid)
+
+                # Search long lived operations for volume
+                action = "complete"
+                for operation in operations["longLivedOpsProgress"]:
+                    if operation["volAction"] is not None:
+                        for key in operation.keys():
+                            if (operation[key] is not None and "volumeRef" in operation[key] and
+                                    (operation[key]["volumeRef"] == self.volume_detail["id"] or
+                                     ("storageVolumeRef" in self.volume_detail and operation[key]["volumeRef"] == self.volume_detail["storageVolumeRef"]))):
+                                action = operation["volAction"]
+                                percent_complete = operation["init"]["percentComplete"]
             except Exception as err:
                 self.module.fail_json(msg="Failed to get volume expansion progress. Volume [%s]. Array Id [%s]."
                                           " Error[%s]." % (self.name, self.ssid, to_native(err)))
 
-            if timeout <= 0:
-                self.module.warn("Expansion action, %s, failed to complete during the allotted time. Time remaining"
-                                 " [%s]. Array Id [%s]." % (action, percent_complete, self.ssid))
-                self.module.fail_json(msg="Expansion action failed to complete. Time remaining [%s]. Array Id [%s]."
-                                          % (percent_complete, self.ssid))
-            if timeout:
-                timeout -= 5
-            self.module.log("Expansion action, %s, is %s complete." % (action, percent_complete))
+            if timeout is not None:
+                if timeout <= 0:
+                    self.module.warn("Expansion action, %s, failed to complete during the allotted time. Time remaining"
+                                     " [%s]. Array Id [%s]." % (action, percent_complete, self.ssid))
+                    self.module.fail_json(msg="Expansion action failed to complete. Time remaining [%s]. Array Id [%s]." % (percent_complete, self.ssid))
+                if timeout:
+                    timeout -= 5
 
+            self.module.log("Expansion action, %s, is %s complete." % (action, percent_complete))
         self.module.log("Expansion action is complete.")
 
     def get_storage_pool(self):
@@ -709,10 +723,6 @@ class NetAppESeriesVolume(NetAppESeriesModule):
                     self.module.fail_json(msg="Failed to expand volume.  Volume [%s].  Array Id [%s]. Error[%s]."
                                               % (self.name, self.ssid, to_native(err)))
 
-                if self.wait_for_initialization:
-                    self.module.log("Waiting for expansion operation to complete.")
-                    self.wait_for_volume_action()
-
                 self.module.log("Volume storage capacities have been expanded.")
 
     def delete_volume(self):
@@ -787,6 +797,10 @@ class NetAppESeriesVolume(NetAppESeriesModule):
                         self.expand_volume()
                         msg = msg[:-1] + " and was expanded." if msg else "Volume [%s] was expanded."
 
+                if self.wait_for_initialization:
+                    self.module.log("Waiting for volume operation to complete.")
+                    self.wait_for_volume_action(timeout=self.initialization_timeout)
+
             elif self.state == 'absent':
                 self.delete_volume()
                 msg = "Volume [%s] has been deleted."
